def bfs(s, adj):
    # Тут храним стоимость прохода до вершины
    cost = [-1] * len(adj)
    # 'Стоимость' пути s -> s = 0
    cost[s-1] = 0
    queue = [s]
    while queue:
        v = queue.pop(0)
        # запускаем обход из вершины v
        for w in adj[v-1]:
            # проверка на посещенность
            if cost[w-1] == -1:
                # добавление вершины в очередь
                queue.append(w)
                # подсчитываем стоимость пути до вершины
                cost[w-1] = cost[v-1] + 1
    return cost


adj = [
    # список смежности
    [2, 4],  # 1
    [1, 3],  # 2
    [2, 7],  # 3
    [1, 5],  # 4
    [4, 6],  # 5
    [5, 7],  # 6
    [3, 6]  # 7
]
v = 1
u = 6
cost = bfs(1, adj)
# Выведем 'стоимость' пути из вершины 1 в 3
# Если cost[u] = -1, значит, вершина u недостижима из стартовой вершины
print(cost[u-1])